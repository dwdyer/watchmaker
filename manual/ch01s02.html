<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>When are Evolutionary Algorithms Useful?</title><link rel="stylesheet" href="docbook.css" type="text/css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"/><meta name="keywords" content="algorithms, evolution, evolutionary algorithms, evolutionary computation, genetic algorithms, Java, programming, software"/><link rel="home" href="index.html" title="Evolutionary Computation in Java"/><link rel="up" href="ch01.html" title="Chapter 1. The Power of Evolution"/><link rel="prev" href="ch01.html" title="Chapter 1. The Power of Evolution"/><link rel="next" href="ch01s03.html" title="Implementing Evolutionary Algorithms"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">When are Evolutionary Algorithms Useful?</th></tr><tr><td align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><th width="60%" align="center">Chapter 1. The Power of Evolution</th><td align="right"> <a accesskey="n" href="ch01s03.html">Next</a></td></tr></table><hr/></div><div class="section" title="When are Evolutionary Algorithms Useful?"><div class="titlepage"><div><div><h2 class="title" id="d0e240">When are Evolutionary Algorithms Useful?</h2></div></div></div><p>
      Evolutionary algorithms are typically used to provide good approximate
      solutions to problems that cannot be solved easily using other techniques.
      Many optimisation problems fall into this category.  It may be too
      computationally-intensive to find an exact solution but sometimes a near-optimal
      solution is sufficient.  In these situations evolutionary techniques can be
      effective.  Due to their random nature, evolutionary algorithms are never guaranteed
      to find an optimal solution for any problem, but they will often find a good solution
      if one exists.
    </p><p>
      One example of this kind of optimisation problem is the challenge of timetabling.
      Schools and universities must arrange room and staff allocations to suit the needs
      of their curriculum.  There are several constraints that must be satisfied.
      A member of staff can only be in one place at a time, they can only teach classes
      that are in their area of expertise, rooms cannot host lessons if they are already
      occupied, and classes must not clash with other classes taken by the same students.
      This is a combinatorial problem and known to be NP-Hard.
      It is not feasible to exhaustively search for the optimal timetable due to the huge
      amount of computation involved.  Instead, heuristics must be used.
      Genetic algorithms have proven to be a successful way of generating satisfactory
      solutions to many scheduling problems.
    </p><p>
      Evolutionary algorithms can also be used to tackle problems that humans don't really
      know how to solve.
      An EA, free of any human preconceptions or biases, can generate surprising solutions
      that are comparable to, or better than, the best human-generated efforts.
      It is merely necessary that we can recognise a good solution if
      it were presented to us, even if we don't know <span class="emphasis"><em>how</em></span> to create a
      good solution.
      In other words, we need to be able to formulate an effective fitness function.
    </p><p>
      Engineers working for NASA know a lot about physics.  They know exactly which
      characteristics make for a good communications antenna.  But the process
      of designing an antenna so that it has the necessary properties is hard.  Even
      though the engineers know what is required from the final antenna, they may not know
      how to design the antenna so that it satisfies those requirements.
    </p><p>
      NASA's Evolvable Systems Group has used evolutionary algorithms to successfully
      evolve antennas for use on satellites.  These evolved antennas have irregular shapes
      with no obvious symmetry (one of these antennas is pictured below).
      It is unlikely that a human expert would have arrived at such an unconventional design.
      Despite this, when tested these antennas proved to be extremely well adapted to their
      purpose.
    </p><div class="informalfigure"><div class="mediaobject" style="text-align: center"><img src="./antenna.jpg" style="text-align: middle" width="100%"/><div class="caption"><p>
            <a class="link" href="http://ti.arc.nasa.gov/projects/esg/research/antenna.htm" target="">NASA Evolvable Systems Group</a>
          </p></div></div></div><div class="section" title="Pre-requisites"><div class="titlepage"><div><div><h3 class="title" id="d0e266">Pre-requisites</h3></div></div></div><span xmlns="" xmlns:d="http://docbook.org/ns/docbook" id="d0e269" class="indexterm"/><p>
        There are two requirements that must be met before an evolutionary algorithm can
        be used for a particular problem.
        Firstly, we need a way to encode candidate solutions to the problem.  The simplest
        encoding, and that used by many genetic algorithms, is a bit string.  Each candidate
        is simply a sequence of zeros and ones.
        This encoding makes cross-over and mutation very straightforward, but that does not
        mean that you cannot use more complicated representations.  In fact, we will see
        several instances of more advanced candidate representations in later chapters.
        As long as we can devise a scheme for evolving the candidates, there really is no
        restriction on the types that we can use.
        Genetic programming (GP) is a good example of this.  GP evolves computer programs
        represented as syntax trees.
      </p><span xmlns="" xmlns:d="http://docbook.org/ns/docbook" id="d0e274" class="indexterm"/><p>
        The second requirement for applying evolutionary algorithms is that there must be a
        way of evaluating partial solutions to the problem - the fitness function.  It is
        not sufficient to evaluate solutions as right or wrong, the fitness score needs to
        indicate <span class="emphasis"><em>how right</em></span> or, if your glass is half empty,
        <span class="emphasis"><em>how wrong</em></span> a candidate solution is.  So a function that returns
        either 0 or 1 is useless.  A function that returns a score on a scale of 1 - 100 is
        better.  We need shades of grey, not just black and white, since this is how the
        algorithm guides the random evolution to find increasingly better solutions.
      </p></div></div><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><td align="center"><a accesskey="u" href="ch01.html">Up</a></td><td align="right"> <a accesskey="n" href="ch01s03.html">Next</a></td></tr><tr><td align="left" valign="top">Chapter 1. The Power of Evolution </td><td align="center"><a accesskey="h" href="index.html">Home</a></td><td align="right" valign="top"> Implementing Evolutionary Algorithms</td></tr></table></div></body></html>